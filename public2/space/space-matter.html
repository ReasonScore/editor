<!doctype html>

<html lang="en">

<head>
    <meta charset="utf-8">
    <title>Reason Score Space Visualization</title>
    <script src="matter.min.js"></script>
</head>

<body>
</body>
<script>
    // Important Environemtn Variables
    var thrustForce = .1;
        stiffness = .05;
        length = 0;
        indicatorStiffness = .04;
        friction = .1;

    var Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Composites = Matter.Composites,
        Common = Matter.Common,
        Constraint = Matter.Constraint,
        MouseConstraint = Matter.MouseConstraint,
        Mouse = Matter.Mouse,
        World = Matter.World,
        Bodies = Matter.Bodies,
        Events = Matter.Events,
        Body = Matter.Body;

    // create engine
    var engine = Engine.create(),
        world = engine.world;
    world.gravity.y = 0;

    // create renderer
    var render = Render.create({
        element: document.body,
        engine: engine,
        options: {
            width: 800,
            height: 600,
            wireframes: false
            // showAngleIndicator: true,
            // showVelocity: true,
        }
    });

    Render.run(render);

    // create runner
    var runner = Runner.create();
    Runner.run(runner, engine);

    // add ruler
    const rulerOptions = {
        isStatic: true, collisionFilter: {
            'group': -1,
            'category': 2,
            'mask': 0,
        }
    }
    World.add(world, [
        Bodies.rectangle(400, 300, 200, 100, rulerOptions),
    ]);

    // add Score Tree
    var bodyMain = Bodies.rectangle(400, 300, 5, 100,
        {
            render:
            {
                fillStyle: '#ffffff',
                lineWidth: 0,
                opacity: .5
            }
        }
    );

    // base constraints
    const baseLinkConstraint = {
        stiffness: stiffness,
        length: length,
        damping: 0,
        render:
        {
            strokeStyle: "#ffffff33"
        }
    }
    var baseMainTopConstraint = {
        ...baseLinkConstraint, ...{
            stiffness: indicatorStiffness,
            length: 0,
            bodyA: bodyMain,
        }
    }
    var constraintMainTop = Constraint.create({
        ...baseMainTopConstraint, ...{
            pointA: { x: 0, y: -50 },
            pointB: { x: 400, y: 250 },
        }
    });
    var constraintMainBottom = Constraint.create({
        ...baseMainTopConstraint, ...{
            pointA: { x: 0, y: 50 },
            pointB: { x: 400, y: 350 },
        }
    });
    World.add(world, [
        bodyMain,
        constraintMainTop,
        constraintMainBottom
    ]);
    const ships = [];

    function createShip(fraction, pro, parent) {
        if (fraction == undefined) {
            fraction = .5
        }
        const result = {
            fraction: fraction,
            pro: pro
        }

        const style = {
            lineWidth: 0,
            fillStyle: pro ? '#c880ff' : '#ffa71a'
        };

        const width = 100 * fraction;
        partA = Bodies.polygon(400, 300, 3, 50 * fraction, { render: style });
        if (pro) {
            Body.setAngle(partA, 180 * (Math.PI / 180))
        }
        partB = Bodies.circle(400, 300, 70 * fraction, { render: { fillStyle: '#ffffff11', } });
        //partB = Bodies.polygon(400, 300, 5,70 * fraction, { render: { fillStyle: '#ffffff11', } });
        result.body = Body.create({
            frictionAir: friction,
            parts: [partA, partB]
        });

        result.constraint = Constraint.create({
            ...baseLinkConstraint, ...{
                bodyA: parent,
                pointA: { x: 0, y: 0 },
                bodyB: result.body,
                pointB: {
                    //x: width / 2 * (pro ? -1 : 1),
                    x: 30 * fraction * (pro ? -1 : 1),
                    y: 0
                },
            }
        });
        result.thrust = function () {
            Body.applyForce(
                result.body,
                result.body.position,
                {
                    x: result.fraction * thrustForce * (result.pro ? 1 : -1),
                    y: 0
                })
        }
        World.add(world, [result.constraint, result.body]);
        ships.push(result)
        return result;
    }

    function createNodule(parent) {
        result = {};

        const style = {
            lineWidth: 0,
            fillStyle: '#ffffffaa',
        };

        result.body = Bodies.circle(400, 300, 10, { render: style });

        result.constraint = Constraint.create({
            ...baseLinkConstraint, ...{
                bodyA: parent,
                pointA: { x: 0, y: 0 },
                bodyB: result.body,
                pointB: { x: 0, y: 0 },
            }
        });
        World.add(world, [result.body, result.constraint]);
        return result;
    }


    //Add all the ships and nodules
    const pro = true, con = false
    //const ship1 = createShip(1, pro, bodyMain)

    const nodule1 = createNodule(bodyMain)
    const ship1 = createShip(.2, pro, nodule1.body)
    const ship2 = createShip(.2, pro, nodule1.body)
    const ship4 = createShip(.6, pro, bodyMain)

    Events.on(engine, 'beforeUpdate', function (event) {

        //Stop the score indicator from rotating
        Body.setAngle(bodyMain, 0);//90 * (Math.PI/180));
        Body.setAngularVelocity(bodyMain, 0);//90 * (Math.PI/180));

        for (const ship of ships) {
            ship.thrust();

            //Stop the ships from rotating
            Body.setAngle(ship.body, 0);//90 * (Math.PI/180));
            Body.setAngularVelocity(ship.body, 0);//90 * (Math.PI/180));
            const v = ship.body.velocity;
            // v.x = v.x * .1;
            // v.y = v.y * .1;
            // Body.setVelocity(ship.body, v);

        }
    });

    // add mouse control
    var mouse = Mouse.create(render.canvas),
        mouseConstraint = MouseConstraint.create(engine, {
            mouse: mouse,
            constraint: {
                // allow bodies on mouse to rotate
                angularStiffness: 0,
                render: {
                    visible: false
                }
            }
        });

    World.add(world, mouseConstraint);

    // keep the mouse in sync with rendering
    render.mouse = mouse;

    // fit the render viewport to the scene
    Render.lookAt(render, {
        min: { x: 0, y: 0 },
        max: { x: 800, y: 600 }
    });

</script>

</html>